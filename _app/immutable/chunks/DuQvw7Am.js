function h(n){const t=n-1;return t*t*t+1}function f(n){const t=typeof n=="string"&&n.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);return t?[parseFloat(t[1]),t[2]||"px"]:[n,"px"]}function x(n,{delay:t=0,duration:d=400,easing:$=h,x:p=0,y:r=0,opacity:l=0}={}){const e=getComputedStyle(n),i=+e.opacity,a=e.transform==="none"?"":e.transform,s=i*(1-l),[_,y]=f(p),[u,m]=f(r);return{delay:t,duration:d,easing:$,css:(c,g)=>`
			transform: ${a} translate(${(1-c)*_}${y}, ${(1-c)*u}${m});
			opacity: ${i-s*g}`}}function b(n,{delay:t=0,duration:d=400,easing:$=h,axis:p="y"}={}){const r=getComputedStyle(n),l=+r.opacity,e=p==="y"?"height":"width",i=parseFloat(r[e]),a=p==="y"?["top","bottom"]:["left","right"],s=a.map(o=>`${o[0].toUpperCase()}${o.slice(1)}`),_=parseFloat(r[`padding${s[0]}`]),y=parseFloat(r[`padding${s[1]}`]),u=parseFloat(r[`margin${s[0]}`]),m=parseFloat(r[`margin${s[1]}`]),c=parseFloat(r[`border${s[0]}Width`]),g=parseFloat(r[`border${s[1]}Width`]);return{delay:t,duration:d,easing:$,css:o=>`overflow: hidden;opacity: ${Math.min(o*20,1)*l};${e}: ${o*i}px;padding-${a[0]}: ${o*_}px;padding-${a[1]}: ${o*y}px;margin-${a[0]}: ${o*u}px;margin-${a[1]}: ${o*m}px;border-${a[0]}-width: ${o*c}px;border-${a[1]}-width: ${o*g}px;min-${e}: 0`}}export{x as f,b as s};
